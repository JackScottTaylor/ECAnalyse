'''
This module is designed to automatically generate a README.md file for a given python module.
The README.md file is generated by extracting the relevant information from the functions and classes.
The README.md file is generated in the same directory as the python module.
The functions in this module are only used internally and it is not intended for the user to call them directly.
'''

import os

def auto_readme(python_file_path):
    '''
    Arguments:
    - python_file_path: str
        The path to the python file for which the README.md file is to be generated.
    
    Methodology:
    - Open the python file and read the contents.
    - Extract the class and function names.
    - For each class and function, extract the docstring.
    - Write the extracted information to the README.md file.

    Examples:
    Before merging with main, the following should be ran to generate the README.md file:
    ```python
    from ECAnalyse.auto_readme import auto_readme
    auto_readme('/path/to/python/file.py')
    ```
    '''

    # Open the python file and read the contents.
    with open(python_file_path, 'r') as file:
        python_file_contents = file.read().split('\n')

    md_text = ''
    
    for i, line in enumerate(python_file_contents):
        stripped_line = line.lstrip()
        if new_section_begins(line):
            md_text += section_title(line)
            doc = doc_string(python_file_contents, i)
            doc = add_bold_to_sections(doc)
            doc = remove_over_linebreaks_python(doc)
            md_text += doc

    # Create a table of contents at the start of the readme file
    # where every section is linked to the relevant section.
    # The entries should be nested according to the section level.
    table_of_contents = '# Table of Contents\n\n'
    for line in md_text.split('\n'):
        stripped_line = line.lstrip()
        if stripped_line.startswith('#'):
            section_level = line.count('#')
            section_name = stripped_line.replace('#', '').strip()
            table_of_contents += '  ' * (section_level - 1) + '- ' + f'[{section_name}](#{section_name.lower().replace(" ", "-")})\n'
    md_text = table_of_contents + '\n' + md_text


    # Add the module docstring to the start of the md_text
    md_text = doc_string(python_file_contents, -1) + md_text
    
    
    # Write the extracted information to the README.md file.
    readme_file_path = python_file_path.replace('.py', '_README.md')
    with open(readme_file_path, 'w') as file:
        file.write(md_text) 


def new_section_begins(line):
    '''
    Arguments:
    - line: str
        The line to be checked.

    Returns:
    - bool
        True if line is start of new function or class, False otherwise.
    '''

    stripped_line = line.lstrip()
    if stripped_line.startswith('class ') or stripped_line.startswith('def '):
        return True
    

def section_title(line):
    '''
    Arguments:
    - line: str
        Line which contains name of function or class

    Returns:
    - str
        The title of the section formatted for the README.md file.
    '''

    stripped_line = line.lstrip()
    section_level = 1 + (len(line) - len(stripped_line)) // 4
    section_name = stripped_line.replace('class ', '').replace('def ', '').split('(')[0].replace(':', '')
    return '#' * section_level + ' ' + '`' + section_name + '`\n\n'


def doc_string(python_file_contents, i):
    '''
    Arguments:
    - python_file_contents: str
        The contents of the python file.
    - i: int
        The index of the line where the class or function is defined.

    Returns:
    - str
        The docstring of the function or class.
    '''
    # Find where docstring begins.
    while python_file_contents[i].strip() != "'''":
        i += 1
    # Extract the docstring and return.
    docstring = ''
    for line in python_file_contents[i + 1:]:
        if line.strip() == "'''": break
        if line.strip().endswith('\\'):
            docstring += line.strip().replace('\\', '')
        else:
            docstring += line.strip() + '\n\n'

    docstring += '\n'
    return docstring


def add_bold_to_sections(doc):
    '''
    Arguments:
    - doc: str
        The docstring of the class or function

    Returns:
    - str
        The docstring with the sections bolded.
    '''

    for section in [
        'Arguments:', 'Returns:', 'Methodology:', 'Examples:', 'Parent Class:', 'Description:', 'Note:'
    ]:
        doc = doc.replace(section, f'**{section}**')
    return doc

def remove_over_linebreaks_python(doc):
    '''
    Description:
    This function identifies any python code blocks in the docstring and replaces double line break with single line break.
    Arguments:
    - doc: str
        The docstring of the class or function

    Returns:
    - str
        The docstring with the over linebreaks removed.
    '''
    starts, ends = [], []
    lines = doc.split('\n\n')
    for i, line in enumerate(lines):
        if line.strip().startswith('```python'): starts.append(i)
        elif line.strip().startswith('```'): ends.append(i)
    for start, end in zip(starts, ends):
        python_block = '\n\n'.join(lines[start:end]) + '\n\n'
        replacement = python_block.replace('\n\n', '\n')
        doc = doc.replace(python_block, replacement)
    
    return doc