'''
This module is designed to automatically generate a README.md file for a given python module.\
The README.md file is generated by extracting the relevant information from the functions and classes.\
The README.md file is generated in the same directory as the python module.\
The functions in this module are only used internally and it is not intended for the user to call them directly.
'''

import os
import pathlib

def write_all_file_readmes():
    '''
    Description:
    This function generates all readme files for all the python files in the ECAnalyse package. 
    init files are ignored.
    '''
    repository_path = pathlib.Path(__file__).parents[1].resolve()
    for root, dirs, files in os.walk(repository_path):
        for file in files:
            if file.endswith('.py') and not file == '__init__.py':
                python_file_path = os.path.join(root, file)
                write_readme(python_file_path)



def write_readme(python_file_path):
    '''
    Description:
    This function generates a README.md file for a given python module. \
    The README.md file is generated by extracting the relevant information from the functions and classes. \
    The README.md file is generated in the same directory as the python module.

    Arguments:
    - python_file_path: str
        The path to the python file for which the README.md file is to be generated.
    '''
    md_text = generate_md_text(python_file_path)
    readme_file_path = python_file_path.replace('.py', '_README.md')
    with open(readme_file_path, 'w') as file:
        file.write(md_text)


def generate_md_text(python_file_path):
    '''
    Description:
    This function generates the text for the README.md file for a given python module.\
    
    Arguments:
    - python_file_path: str
        The path to the python file for which the README.md file is to be generated.
    
    Returns:
    - md_text: str
        The text for the README.md file.
    '''
    md_text = ''
    object_names, docstrings = extract_all_function_classes_docstrings(python_file_path)
    for object_name, docstring in zip(object_names, docstrings):
        md_text += object_name + '\n\n'
        md_text += docstring + '\n\n'
    md_text = add_table_of_contents(md_text)
    md_text = make_sections_bold(md_text)
    return md_text


def extract_all_function_classes_docstrings(python_file_path):
    '''
    Description:
    This function extracts all the function and class names and their docstrings from a given python module.
    
    Arguments:
    - python_file_path: str
        The path to the python file for which the function and class names and docstrings are to be extracted.
    
    Returns:
    - object_names: list
        A list of all the function and class names in the python module.
    - docstrings: list
        A list of all the docstrings of the functions and classes in the python module.
    '''
    
    with open(python_file_path, 'r') as file:
        python_file_contents = file.read().split('\n')

    object_names, docstrings = [], []
    
    for i, line in enumerate(python_file_contents):
        if line.strip().startswith('def ') or line.strip().startswith('class '):
            object_name, object_name_end = extract_full_object_name(i, python_file_contents)
            indent_count = object_name.count('#')
            docstring_start = object_name_end + 1
            object_names.append(object_name)
            docstring = ''
            if python_file_contents[docstring_start].strip().startswith("'''"):
                j = docstring_start + 1
                while "'''" not in python_file_contents[j]:
                    line = python_file_contents[j]
                    for k in range(indent_count):
                        line = line[4:]
                    docstring += line + '\n'
                    j += 1
            else:
                readable_object_name = object_name.replace('#', '').split("(")[0]
                print(f'No docstring found for{readable_object_name}')
            docstring = format_arguments_returns(docstring)
            docstrings.append(docstring)
    
    return object_names, docstrings



def extract_full_object_name(i, python_file_contents):
    '''
    Description:
    This function extracts the full name of thefunction or class whose definition begins \
    at the line number i in the python file. The full name includes a number of hashtags \
    at the start to indicate indentation level which MarkDown uses to create sections.

    Arguments:
    - i: int
        The line number at which the function or class definition begins.
    - python_file_contents: list
        The contents of the python file as a list of strings.

    Returns:
    - full_object_name: str
        The full name of the function or class.
    - i: int
        The line number at which the function or class definition ends.
    '''

    line = python_file_contents[i]
    full_object_name = ''
    full_object_name += '#' * ((len(line) - len(line.lstrip())) // 4 + 1) + ' '
    if line.strip().startswith('def '):
        full_object_name += line.strip().replace('def ', '')
    if line.strip().startswith('class '):
        full_object_name += line.strip().replace('class ', '')
    while ':' not in python_file_contents[i]:
        i += 1
        full_object_name += ' ' + python_file_contents[i].strip()
    full_object_name = full_object_name.replace(':', '')
    full_object_name = full_object_name.replace(' )', ')')
    return full_object_name, i

def add_table_of_contents(md_text):
    '''
    Description:
    This function adds a table of contents to the README.md file.
    
    Arguments:
    - md_text: str
        The text of the README.md file.
    
    Returns:
    - md_text: str
        The text of the README.md file with the table of contents added.
    '''
    table_of_contents = '# Table of Contents\n\n'
    for line in md_text.split('\n'):
        stripped_line = line.lstrip()
        if stripped_line.startswith('#'):
            section_level = line.count('#')
            section_name = stripped_line.replace('#', '').strip()
            table_of_contents += '  ' * (section_level - 1) + '- ' + f'[{section_name}](#{section_name.lower().replace(" ", "-")})\n'
    md_text = table_of_contents + '\n' + md_text
    return md_text

def make_sections_bold(md_text):
    '''
    Description:
    This function makes the section titles in the README.md file bold.
    
    Arguments:
    - md_text: str
        The text of the README.md file.
    
    Returns:
    - md_text: str
        The text of the README.md file with the section titles made bold.
    '''
    for section in [
        'Arguments:', 'Returns:', 'Methodology:', 'Examples:', 'Parent Class:', 'Description:'
    ]:
        md_text = md_text.replace(section, f'\n---\n\n**{section}**\n\n---')
    return md_text


def format_arguments_returns(docstring):
    '''
    Description:
    This function formats the arguments and returns sections of the docstring.

    Arguments:
    - docstring: str
        The docstring of the function or class.
    
    Returns:
    - docstring: str
        The docstring with the arguments and returns sections formatted.
    '''
    section_labels = ['Arguments:', 'Returns:', 'Methodology:', 'Examples:', 'Parent Class:', 'Description:']
    lines = docstring.split('\n')
    for i, line in enumerate(lines):
        if 'Arguments:' in line:
            arg_sec = ''
            for j in range(i + 1, len(lines)):
                if lines[j].strip() in section_labels: break
                arg_sec += lines[j] + '\n'
            
            arg_count = 1
            for k in range(i + 1, j + 1):
                if lines[k].strip().startswith('- '):
                    lines[k] = lines[k].replace('- ', '').lstrip()
                    lines[k] = '**' + lines[k] + '**'
                    lines[k] = f'{arg_count}. ' + lines[k] + '\n'
                    lines[k] = lines[k].replace(': ', '  :  ')
                    arg_count += 1
                else:
                    lines[k] = lines[k] + '\n'

        if 'Returns:' in line:
            ret_sec = ''
            for j in range(i + 1, len(lines)):
                if lines[j].strip() in section_labels: break
                ret_sec += lines[j] + '\n'
            
            ret_count = 1
            for k in range(i + 1, j + 1):
                if lines[k].strip().startswith('- '):
                    lines[k] = lines[k].replace('- ', '').lstrip()
                    lines[k] = '**' + lines[k] + '**'
                    lines[k] = f'{ret_count}. ' + lines[k] + '\n'
                    lines[k] = lines[k].replace(': ', '  :  ')
                    ret_count += 1
                else:
                    lines[k] = lines[k] + '\n'
            
    docstring = '\n'.join(lines)
    return docstring

